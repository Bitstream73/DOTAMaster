#Const devmode = True

Imports DotaMasterWPF.PageHandler
Public Class Hero_Item_Inventory
  Implements iItem_Inventory


  Private mParent As iDisplayUnit
  Public mItemBuildSequence As New Item_List 'list of items actually selected by the build author
  Public mItemBuildAndAutoGeneratedItems As New Item_List 'mitembuildsequence plus any items that result for combinations of build author selected items

  Private mGoldCurve As EconomyCurve
  Private mXPCurve As EconomyCurve

  Public mDevNotes As New List(Of String)

  Private mTeamEnemyTarget As dvID = Nothing
  Private mTeamFriendlyTarget As dvID = Nothing
  Private mTargetFriendBias As Boolean

  Private mGame As dGame
  Public Sub New(parent As iDisplayUnit, _
                 goldcurve As EconomyCurve, xpcurve As EconomyCurve, _
                 itemlist As Item_List, _
                 game As dGame)

    UpdateItemSequence(parent, goldcurve, xpcurve, itemlist, game)
  End Sub
  Public Sub UpdateItemSequence(parent As iDisplayUnit, thegoldcurve As EconomyCurve, thexpcurve As EconomyCurve, theitemlist As Item_List, thegame As dGame)

    mGame = thegame
    mParent = parent

    mGoldCurve = thegoldcurve
    mXPCurve = thexpcurve

    mItemBuildSequence = AssembleItems(theitemlist)


#If devmode Then
    mDevNotes.Add("Itembuildsequence: ")
    Dim istr As String = ""
    For i As Integer = 0 To mItemBuildSequence.Count - 1
      istr += mItemBuildSequence.Item(i).ItemName.ToString & ", "
    Next
    mDevNotes.Add(istr)
#End If
    CalcItemTimings()
  End Sub
  Public Sub CalcItemTimings()
    If mItemBuildSequence.Count < 1 Then Exit Sub

    'add all current items to itemsowned
    mItemBuildAndAutoGeneratedItems.Clear()
    For i As Integer = 0 To mItemBuildSequence.Count - 1
      mItemBuildAndAutoGeneratedItems.Add(mItemBuildSequence.Item(i))
    Next


    Dim currItemList As New Item_List
    Dim nexttobuyitemindex As Integer = 0

    Dim GoldSpent As Integer = 0 'buying items
    Dim GoldCredits As Integer = 0 'gold from selling back items
    Dim GoldBalance As Integer = 0 'final balance after credits



    Dim tempcount As Integer = 0

    Dim thedates = mGame.TimeKeeper.TimePoints

    For i As Integer = 0 To thedates.TheFrames.Count - 1

      tempcount += 1
      If tempcount = 51 Then
        Dim c = 2
      End If
      Dim currtime = thedates.Item(i)
      Dim currgold = mGoldCurve.GetValueForTime(currtime)
      Dim friendlytime = Helpers.GetFriendlyTime(currtime)

      'check to make sure we haven't already finished all items
      If nexttobuyitemindex >= mItemBuildSequence.Count Then
        Exit For
      Else
        Dim curitem = mItemBuildSequence.Item(nexttobuyitemindex)
        Dim curitemlevel = curitem.CurrentLevel
        'set current gold stats
        Dim networth As Integer = currgold + Constants.cStartingGold
        GoldBalance = networth + GoldCredits - GoldSpent


        Dim curherolevel = mXPCurve.GetLevelForTime(currtime)


        RemoveExpiredItems(currItemList, curherolevel, currtime)




        'check previous items to see if any can be compined to make current item
        'note possible credits and items
        'remove them from the needed comps to build item
        Dim availablecredit As Integer = 0
        Dim possibleitemstoSell As New Item_List
        Dim possibleitemstoRemove As New Item_List
        Dim possibleitemstoAdd As New Item_List
        Dim compsneededtobuilditem As New Item_List


        Dim complist As New Item_List
        'Dim buildsfrom = mGame.dbItems.CreateItemInstances(curitem.mBuildsFromNames, curitem.ParentID, Constants.cDefaultLifetime)

        Dim buildsfrom = curitem.GetBuildsFromItem_Infos(mGame.dbItems)

        If buildsfrom.Count > 0 Then
          complist = buildsfrom

          'load up the components needed list
          For x As Integer = 0 To complist.Count - 1
            compsneededtobuilditem.Add(complist.Item(x))
          Next


          'figure out which components we don't have on hand
          'and figure out possible gold credits
          For x As Integer = 0 To complist.Count - 1
            Dim thename As eItemname = complist.Item(x).ItemName

            If ListContainsItem(currItemList, thename) Then

              Dim remitem As Item_Info = GetItemFromName(currItemList, thename)
              If compsneededtobuilditem.ContainsName(remitem.ItemName) Then

                compsneededtobuilditem.RemoveByName(remitem.ItemName)

                possibleitemstoSell.Add(remitem)
                availablecredit += remitem.GoldCost.Value(curitemlevel) / 2

              End If
            End If
          Next
        End If







        'check items for any that are set to disassemble
        'if there are some, check if components are usable by curitem
        'if so, note possible credit and add item to complist
        For y As Integer = 0 To currItemList.Count - 1
          Dim curinventoryitem = currItemList.Item(y)

          If curinventoryitem.Willdisassemble Then
            'Dim InvItemcomps = mGame.dbItems.CreateItemInstances(curinventoryitem.mBuildsFromNames, curinventoryitem.ParentID, Constants.cDefaultLifetime)
            'Dim NewItemcomps = mGame.dbItems.CreateItemInstances(curitem.mBuildsFromNames, curitem.ParentID, Constants.cDefaultLifetime)

            Dim InvItemcomps = curinventoryitem.GetBuildsFromItem_Infos(mGame.dbItems)
            Dim NewItemcomps = curitem.GetBuildsFromItem_Infos(mGame.dbItems)

            For z As Integer = 0 To InvItemcomps.Count - 1
              If InvItemcomps.ContainsName(NewItemcomps.Item(z).ItemName) Then
                Dim remitem As Item_Info = InvItemcomps.Item(z)

                If compsneededtobuilditem.ContainsName(remitem.ItemName) Then
                  compsneededtobuilditem.RemoveByName(remitem.ItemName)

                  possibleitemstoSell.Add(remitem)
                  availablecredit += remitem.GoldCost.Value(curitemlevel) / 2

                End If


                'mark the item that's destroyed by disassembly for possible removal
                If Not possibleitemstoRemove.Contains(curinventoryitem) Then
                  possibleitemstoRemove.Add(curinventoryitem)
                End If

              Else 'new item doesn't contain component se we are either saving or selling the unused component
                If InvItemcomps.Item(z).ItemPlan = eItemPlan.SellAtOnce Then
                  possibleitemstoSell.Add(InvItemcomps.Item(z))
                Else
                  'we aren't selling the component so we must be holding on to it
                  possibleitemstoAdd.Add(InvItemcomps.Item(z))
                End If
              End If
            Next

          End If

        Next










        'check to see if between our balance and available credits we have enough to buy item
        If curitem.GoldCost.Value(curitemlevel) <= GoldBalance Then
          'we are buying the item

          nexttobuyitemindex += 1

          GoldCredits += availablecredit


          GoldSpent += curitem.GoldCost.Value(curitemlevel)


          GoldBalance = networth - GoldSpent + GoldCredits


          'items are combined so remove sellable components, update life and level times
          For x As Integer = 0 To possibleitemstoSell.Count - 1
            Dim compitem As Item_Info = possibleitemstoSell.Item(x)

            Dim start As ddFrame = compitem.Lifetime.CreationTime

            SetNewLifetime(start, currtime, compitem)
            SetNewLevelRange(compitem)
            Dim remitem = possibleitemstoSell.Item(x)



            currItemList.RemoveByName(remitem.ItemName)
          Next


          'remove any items destroyed by disassembly, update life and level times
          For x As Integer = 0 To possibleitemstoRemove.Count - 1
            Dim remitem = possibleitemstoRemove.Item(i)

            SetNewLifetime(remitem.Lifetime.CreationTime, currtime, remitem)
            SetNewLevelRange(remitem)

            Dim remitem2 = possibleitemstoRemove.Item(i)




            currItemList.RemoveByName(remitem2.ItemName)
          Next


          'add any components that are now items
          For y As Integer = 0 To possibleitemstoAdd.Count - 1
            Dim additem = possibleitemstoAdd.Item(y)

            SetNewLifetime(currtime, mGame.TimeKeeper.GameEnd, additem)
            SetNewLevelRange(additem)





            currItemList.Add(additem)
            If Not mItemBuildAndAutoGeneratedItems.Contains(additem) Then
              mItemBuildAndAutoGeneratedItems.Add(additem)
            End If
          Next


          'add new item and set it's creation time
          SetNewLifetime(currtime, mGame.TimeKeeper.GameEnd, curitem)
          SetNewLevelRange(curitem)


          currItemList.Add(curitem)
          If Not mItemBuildAndAutoGeneratedItems.Contains(curitem) Then
            mItemBuildAndAutoGeneratedItems.Add(curitem)
          End If


        End If


        'combine any combinable items

        Dim dura As New ddFrame(mGame.TimeKeeper.GameDuration.count - currtime.count) 'TimeSpan(mTimeKeeper.GameDuration.Ticks - currtime.Ticks)

        CombineItems(currItemList, mParent, currtime)

        If currItemList.Count > 10 Then
          Dim d = 2
        End If

        'if we have more than 6 items currently, sell oldest ones marked to sell for space
        If currItemList.Count > 6 Then
          currItemList.SortByCreationTime()

          For x As Integer = 0 To currItemList.Count - 1
            Dim theitem = currItemList.Item(x)

            If theitem.ItemPlan = eItemPlan.SellForSpace Then

              SetNewLifetime(theitem.Lifetime.CreationTime, currtime, theitem)
              SetNewLevelRange(theitem)



              currItemList.Remove(theitem)
              If currItemList.Count <= 6 Then Exit For
            End If

          Next
        End If

        For z As Integer = 0 To currItemList.Count - 1

          Dim theitem As Item_Info = currItemList.Item(z)


        Next
        'we've got our final list, now lets add it's id's to master list
        'itemids = GetIdsForlist(currItemList)

#If devmode Then
        Dim outstring As String = friendlytime & ": "
        For x As Integer = 0 To currItemList.Count - 1
          Dim outitem = currItemList.Item(x)
          Dim smId = outitem.Id.ToString
          smId = smId.Substring(0, 3)
          outstring += "| " & Helpers.GetFriendlyTime(outitem.Lifetime.CreationTime) & " - " & Helpers.GetFriendlyTime(outitem.Lifetime.EndTime)
          outstring += " " & smId & " " & outitem.ItemName.ToString & ", "
        Next
        mDevNotes.Add(outstring)
#End If



      End If

    Next



  End Sub
  Public Sub UpdateAllItemsTargets(enemytarg As iDisplayUnit, friendtarg As iDisplayUnit, bias As Boolean) Implements iItem_Inventory.UpdateAllItemsTargets
    mItemBuildAndAutoGeneratedItems.UpdateTargets(enemytarg, friendtarg, bias)
  End Sub

#Region "Info"
  Public Function GetItemsAtTime(thetime As ddFrame) As Item_List Implements iItem_Inventory.GetItemsAtTime
    Dim outlist As New Item_List
    For i As Integer = 0 To mItemBuildAndAutoGeneratedItems.Count - 1
      Dim theitem = mItemBuildAndAutoGeneratedItems.Item(i)

      If theitem.ExistsAtTime(thetime) Then outlist.AddItem(theitem)
    Next

    Return outlist


  End Function

  Public Function HasAghs() As Boolean Implements iItem_Inventory.HasAghs
    If mItemBuildAndAutoGeneratedItems.ContainsName(eItemname.itmAGHANIMS_SCEPTER) Then Return True

    Return False
  End Function

  Public Function HasAghsAtTime(thetime As ddFrame) As Boolean Implements iItem_Inventory.HasAghsAtTime

    If mItemBuildAndAutoGeneratedItems.ContainsName(eItemname.itmAGHANIMS_SCEPTER) Then
      Dim aghs = mItemBuildAndAutoGeneratedItems.GetItemByName(eItemname.itmAGHANIMS_SCEPTER)

      If aghs IsNot Nothing Then
        If aghs.Lifetime.LifeTimeContainsTime(thetime) Then Return True
      End If
    End If
    Return False
  End Function

  Public Function GetAghsLifetime() As Lifetime Implements iItem_Inventory.GetAghsLifetime
    If mItemBuildAndAutoGeneratedItems.ContainsName(eItemname.itmAGHANIMS_SCEPTER) Then
      Return mItemBuildAndAutoGeneratedItems.GetItemByName(eItemname.itmAGHANIMS_SCEPTER).Lifetime
    End If

    Return Nothing
  End Function
  Public Function GetItemBuildAndAutoGeneratedItems() As Item_List Implements iItem_Inventory.GetItemBuildAndAutoGeneratedItems
    Return mItemBuildAndAutoGeneratedItems
  End Function
#End Region

  Public Function GetItemBuildAndAutoGeneratedItemsAsGameEntities() As List(Of iGameEntity) Implements iItem_Inventory.GetItemBuildAndAutoGeneratedItemsAsGameEntities
    Dim outlist As New List(Of iGameEntity)

    For i = 0 To mItemBuildAndAutoGeneratedItems.Count - 1
      outlist.Add(mItemBuildAndAutoGeneratedItems.Item(i))

    Next
    Return outlist

  End Function

#Region "Private Helpers"
  Private Function ContainsdvID(thelist As Item_List, thedvID As dvID) As Boolean


    For i As Integer = 0 To thelist.Count - 1
      If thelist.Item(i).Id Is thedvID Then Return True
    Next
    Return False
  End Function

  Private Function GetIdsForlist(thelist As Item_List) As List(Of dvID)
    Dim outlist As New List(Of dvID)
    For i As Integer = 0 To thelist.Count - 1
      outlist.Add(thelist.Item(i).Id)
    Next

    Return outlist
  End Function

  Private Function GetListforIDItems(theiditems As List(Of dvID)) As Item_List
    Dim outlist As New Item_List
    For i As Integer = 0 To theiditems.Count - 1
      Dim theitem = mItemBuildAndAutoGeneratedItems.GetItemByIdItem(theiditems.Item(i))
      If Not theitem Is Nothing Then
        outlist.Add(theitem)
      Else
        Dim x = 2
      End If

    Next
    Return outlist
  End Function
  Private Sub UpdateComponentStatus(theitem As Item_Info, thestatus As eItemPlan)

    Dim thecomplist = theitem.GetBuildsFromItem_Infos(mGame.dbItems)
    For i As Integer = 0 To thecomplist.Count - 1
      If thecomplist.Item(i).Id Is theitem.Id Then
        thecomplist.Item(i).ItemPlan = thestatus
      End If
    Next

  End Sub
  Private Sub CombineItems(theitems As Item_List, theparent As iDisplayUnit, currenttime As ddFrame)
    Dim itemswithingreds = mGame.dbItems.mItemsWithIngredients
    Dim assembleditems = mGame.dbItems.mItemsThatAreAssemled
    Dim itemingredients = mGame.dbItems.mItemsthatAreIngredients
    Dim combinableitems As New Item_List

    For i As Integer = 0 To theitems.Count - 1
      If itemingredients.ContainsKey(theitems.Item(i).ItemName) Then
        combinableitems.Add(theitems.Item(i))
      End If
    Next


    If combinableitems.Count < 2 Then Exit Sub


    For i As Integer = 0 To combinableitems.Count - 1
      Dim newitemcandidates = itemingredients.Item(combinableitems.Item(i).ItemName)

      For x As Integer = 0 To newitemcandidates.Count - 1

        If ContainsAllComponents(combinableitems, newitemcandidates.Item(x)) Then
          Dim assembleditem = newitemcandidates.Item(x)

          Dim newlife As New Lifetime(currenttime, mGame.TimeKeeper.GameDuration)

          Dim newitem = mGame.dbItems.CreateItemInstance(assembleditem, theparent, newlife)

          SetNewLifetime(currenttime, mGame.TimeKeeper.GameEnd, newitem)
          SetNewLevelRange(newitem)




          theitems.Add(newitem)

          Dim theingredients = itemswithingreds.Item(assembleditem)
          For y As Integer = 0 To theingredients.Count - 1
            Dim remitem = mItemBuildAndAutoGeneratedItems.GetByName(theingredients.Item(y))


            If theitems.Contains(remitem) Then

              SetNewLifetime(remitem.Lifetime.CreationTime, currenttime, remitem)
              SetNewLevelRange(remitem)



              theitems.Remove(remitem)
            End If

          Next
        End If
      Next
    Next



  End Sub

  Private Sub RemoveExpiredItems(thelist As Item_List, currentlevel As Integer, currenttime As ddFrame)
    For i As Integer = thelist.Count - 1 To 0 Step -1
      Dim theitem = thelist.Item(i)
      Dim lvlcount As Integer = 0

      Select Case theitem.ItemPlan
        Case eItemPlan.UseFor1Level
          lvlcount = 1
        Case eItemPlan.UseFor2Levels
          lvlcount = 2
        Case eItemPlan.UseFor3Levels
          lvlcount = 3
        Case eItemPlan.UseFor4Levels
          lvlcount = 4
        Case eItemPlan.UseFor5Levels
          lvlcount = 5
      End Select


      If lvlcount > 0 Then

        If theitem.BoughtAtLevel + lvlcount <= currentlevel Then


          SetNewLifetime(theitem.Lifetime.CreationTime, currenttime, theitem)
          SetNewLevelRange(theitem)

#If devmode Then
          mDevNotes.Add(theitem.ItemName.ToString & "-RemovedExpiredItems")
          mDevNotes.Add("BoughtatLevel: " & theitem.BoughtAtLevel.ToString)
          mDevNotes.Add("Hold forlevels: " & lvlcount.ToString)
          mDevNotes.Add("CurrentLevel: " & currentlevel)
          mDevNotes.Add("Start: " & Helpers.GetFriendlyTime(theitem.Lifetime.CreationTime))
          mDevNotes.Add("End: " & Helpers.GetFriendlyTime(theitem.Lifetime.EndTime))
#End If



          thelist.Remove(theitem)

        End If

      End If

    Next

  End Sub

  Private Sub SetNewLifetime(thestart As ddFrame, theend As ddFrame, theitem As Item_Info)

    Dim newlife As New Lifetime(thestart, theend)

    theitem.Lifetime = newlife
  End Sub

  Private Function ContainsAllComponents(thecomplist As Item_List, theitem As eItemname) As Boolean

    Dim compsneeded = mGame.dbItems.GetItemInfoNoParent(theitem).MadeFromItemNames

    If compsneeded.Count < 1 Then Return False

    For i As Integer = 0 To compsneeded.Count - 1

      If Not thecomplist.ContainsName(compsneeded.Item(i)) Then Return False

    Next
    Return True

  End Function

  Private Sub SetNewLevelRange(theitem As Item_Info)
    Dim startlevel = mXPCurve.GetLevelForTime(theitem.Lifetime.CreationTime)
    Dim endleve = mXPCurve.GetLevelForTime(theitem.Lifetime.EndTime)

    theitem.BoughtAtLevel = startlevel
    theitem.SoldAtLevel = endleve
  End Sub

  Private Function GetItemFromdvID(thelist As Item_List, thedvID As dvID) As Item_Info

    For i As Integer = 0 To thelist.Count - 1
      If thelist.Item(i).Id Is thedvID Then Return thelist.Item(i)
    Next
    Return Nothing

  End Function

  Private Function GetItemFromName(thelist As Item_List, thename As eItemname) As Item_Info
    For i As Integer = 0 To thelist.Count - 1
      Dim theitem As Item_Info = thelist.Item(i)
      If theitem.ItemName = thename Then Return theitem
    Next
    Return Nothing
  End Function

  Private Sub RemoveComponentsFromList(thelist As Item_List, theitem As Item_Info)

    Dim buildsfrom = mGame.dbItems.GetItemInfosNoParent(theitem.MadeFromItemNames)
    For i As Integer = 0 To buildsfrom.Count - 1
      Dim thecomp As Item_Info = buildsfrom.Item(i)
      If thelist.Contains(thecomp) Then
        thelist.Remove(thecomp)


      End If
    Next


  End Sub

  Private Function GetComponentsFromList(thelist As Item_List, theitem As Item_Info) As Item_List
    Dim outlist As New Item_List
    Dim buildsfrom = theitem.GetBuildsFromItem_Infos(mGame.dbItems)
    For i As Integer = 0 To buildsfrom.Count - 1
      Dim thecomp As Item_Info = buildsfrom.Item(i)
      If thelist.Contains(thecomp) Then
        outlist.Add(thecomp)


      End If
    Next

    Return outlist

  End Function

  Private Function ListContainsItem(thelist As Item_List, thename As eItemname) As Boolean
    For i As Integer = 0 To thelist.Count - 1
      Dim theitem = GetItemFromdvID(mItemBuildAndAutoGeneratedItems, thelist.Item(i).Id)
      If Not theitem Is Nothing Then
        If theitem.ItemName = thename Then Return True
      End If

    Next

    Return False
  End Function



  Private Function AssembleItems(thelist As Item_List) As Item_List

    Dim assemblyparts As New Item_List

    'find the parts
    For i As Integer = 0 To thelist.Count - 1
      'check if parentID is an item_info or a herobuild
      If thelist.ContainsIDItem(thelist.Item(i).ParentGameEntity.Id) Then
        thelist.Item(i).ItemIsFromDisassembly = True
        assemblyparts.Add(thelist.Item(i))
      End If
    Next
    'remove parts from original list
    For i As Integer = 0 To assemblyparts.Count - 1
      thelist.Remove(assemblyparts.Item(i))

    Next
    'If mUniqueName = "AA1" Then
    '  Dim x = 2
    'End If
    'add parts back into their owners
    For i As Integer = 0 To assemblyparts.Count - 1
      If ContainsdvID(thelist, assemblyparts.Item(i).ParentGameEntity.Id) Then
        Dim theiteminfo = GetItemFromdvID(thelist, assemblyparts.Item(i).ParentGameEntity.Id)
        Dim thepart = assemblyparts.Item(i)
        '        assemblyparts.Item(i).UpdateComponentStatus(thepart, thepart.mItemplan)
        UpdateComponentStatus(thepart, thepart.ItemPlan)

      End If
    Next

    Return thelist
  End Function


  Private Sub RefreshItemIndexes()
    For i As Integer = 0 To mItemBuildSequence.Count - 1
      mItemBuildSequence.Item(i).Index = i
    Next
  End Sub
#End Region

#Region "CRUD"

  Public Sub AddItem(theitem As Item_Info)
    If ContainsdvID(mItemBuildSequence, theitem.Id) Then
      DeleteItemByID(theitem.Id)
    End If

    mItemBuildSequence.Add(theitem)

    RefreshItemIndexes()
    CalcItemTimings()

  End Sub
  Public Sub ReplaceItemAtIndex(theitem As Item_Info, theindex As Integer) Implements iItem_Inventory.ReplaceItemAtIndex


    DeleteItemAtIndex(theindex)


    If theindex >= mItemBuildSequence.Count Then

      mItemBuildSequence.Add(theitem)
      RefreshItemIndexes()
      CalcItemTimings()
      Exit Sub
    End If

    mItemBuildSequence.Insert(theindex, theitem)
    RefreshItemIndexes()
    CalcItemTimings()




    'RaiseEvent isDirty(Me)
  End Sub
  Public Sub DeleteItemAtIndex(theindex As Integer) Implements iItem_Inventory.DeleteItemAtIndex

    If theindex <= mItemBuildSequence.Count - 1 Then

      Dim theitem = mItemBuildSequence.Item(theindex)
      mGame.dbModifiers.RemoveModifiersForSourceID(theitem.Id)
      mItemBuildSequence.RemoveAt(theindex)
    End If

    RefreshItemIndexes()
    CalcItemTimings()
    'RaiseEvent isDirty(Me)
  End Sub

  Public Sub DeleteItemByID(id As dvID) Implements iItem_Inventory.DeleteItemByID
    For i As Integer = 0 To mItemBuildSequence.Count - 1

      If mItemBuildSequence.Item(i).Id Is id Then
        Dim theitem = mItemBuildSequence.Item(i)
        mGame.dbModifiers.RemoveModifiersForSourceID(theitem.Id)
        mItemBuildSequence.Remove(mItemBuildSequence.Item(i))
      End If
    Next

    RefreshItemIndexes()
    CalcItemTimings()
  End Sub

  Public Sub InsertItemAtIndex(index As Integer, item As Item_Info) Implements iItem_Inventory.InsertItemAtIndex

    If index < mItemBuildSequence.Count Then

      mItemBuildSequence.Insert(index, item)
    Else

      mItemBuildSequence.Add(item)
    End If

    RefreshItemIndexes()
    CalcItemTimings()

  End Sub
#End Region























End Class
